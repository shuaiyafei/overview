### 作用域和闭包

#### 编译原理

尽管通常将JavaScript归类为动态和解释执行的语言
事实上它是一门编译语言 与传统的编译语言不通 它不是提前编译的 编译结果也不能在分布式系统中进行移植

在传统编译语言的流程中 程序中的一段源代码在执行前会经历三个步骤 被称为编译

- 分词/词法分析

	这个过程会将由字符组成的字符串分解成有意义的代码 这些代码块被称为词法单元
	
	```
	var a = 2;
	// 被分解称为
	var、a、=、2、;
	// 空格是否被当做词法单元 取决于空格在这门语言是否具有意义
	```
	
- 解析/语法分析

	这个过程是将词法单元流(数组)转换成一个由元素逐级嵌套所组成的代表了程序语法结构的树 这个树被称为抽象语法书
	
- 代码生成
	
	将AST转换为可执行的过程被称为代码生成 这个过程与语言、目标平台息息相关
	
#### 理解作用域

- 引擎

	从头到尾负责整个JavaScript程序的编译及执行过程

- 编译器

	负责语法分析以及代码生成
	
- 作用域

	负责收集并维护所有声明的标识符 确定当前代码对这些标识符的访问权限
	

#### 对话

编译器首先会将这段程序分解成词法单元 然后将词法单元解析成一个树结构 当编译器开始进行代码生成时 对这段程序的处理方式会和预期有所不同

- 遇到var a 编译器会查询作用域是否已经有了一个该名称的变量存在于同一个作用域的集合中 编译器会忽略该声明 继续进行编译 否则它会要求作用域在当前作用域的集合中声明一个新的比那两 并命名为a

- 接下来编译器会为引擎生成运行时所需要的代码 这些代码被用来处理a = 2这个赋值的操作 引擎运行时会首先询问作用域 在当前作用域的集合中检查是否存在一个叫做a的变量 如果是 引擎就会使用这个变量 如果否 会继续查找这个变量

如果引擎最终找到了a变量 就会将2赋值给它

变量的赋值操作会执行两个动作 首先编译器会在当前作用域中声明一个变量 然后在运行时引擎会在作用域中查找该变量 如果能够找到就会对他赋值


#### 编译器

#### 引擎和作用域

```
function foo(a) {
	console.log(a) // 2
}

foo(2);
```

#### 小测验

#### 作用域嵌套

当一个块或函数嵌套在另一个块或者函数中时 就发生了作用域嵌套 在当前作用域无法找到某个变量时 引擎就会在外层嵌套的作用域中继续查找 直到找到该变量 或者抵达最外层的作用域

```
function foo(a) {
	console.log(a + b);
}

var b = 2;
foo2()
```

引擎从当前的执行作用域开始查找变量 如果找不到 就向上一级继续查找 当抵达最外层的全局作用域时 无论是找到或者没找到 查找过程都会停止

**作用域是一个向上查找的过程**



#### 异常

在变量还没有声明的情况下 两种情况的查询方式都是不一样的

```
function foo(a) {
	console.log(a + b);
	b = a;
}

```

引擎在执行查询操作时 如果无法找到目标变量的全局作用域 会自动帮忙创建一个

#### 小结

作用域是一套规则 用于确定在在何处以及如何查找变量(标识符) 如果查找的目的是对变量进行赋值 就会使用LHS查询 如果目的是获取变量的值 就会使用RHS查询

JavaScript引擎首先会在代码执行前对其进行编译 在这个过程中 像var a = 2 这样的声明会被分解为两个独立的操作

- var a 在其作用域中声明新变量 这会在最开始的阶段 也就是代码执行前进行
- a = 2会查询(LHS查询)变量a对其进行赋值

LHS和RHS查询都会在当前执行的作用域中开始 如果有需要(也就是说它们没有找到所需的标识符) 就会向上级作用域继续查找目标标识符 这样每次上升以及的作用域 最后达到全局作用域 无论找到没找到都会停止

